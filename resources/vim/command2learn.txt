--------------------------------------------------------------------------------
				Vim command to learn
--------------------------------------------------------------------------------


[Normal]

ZZ 		Write current file, if modified, and exit.
gf 		Edit the file whose name is under or after the cursor. Mnemonic: "goto file".

V		Enter visual mode linewise
C-v		Enter visual mode for block selection
R		Replace mode
A		Place at the end of the line and enter Insert mode

f		Finds specified character to the right of the cursor position
F		Finds specified character to the left of the cursor position
;		Move to next occurence of f/F
,		Move to previous occurence of f/F
C-r		Redo
o		Begin a new line BELOW the cursor and insert text
s		Substitutes the character(or the selection of characters)
S		Substitutes the entire line
c		Change(not very well understand for the moment)
cc		Erase current line and set insert mode
cw		Erase word and set insert mode
D 		Delete the characters under the cursor until the end of the line
~ 		Switch case of the character under the cursor and move the cursor to the right. If a [count] is given, do that many characters.
.		Repeats the last INSERT edit
gx		Opens the URL under the cursor in a web browser

q[a-z]		Start recording, everything will be recorded including movement actions
@[a-z]		Excecute the recorded actions

w        	jump by start of words (punctuation considered words)
e        	jump to end of words (punctuation considered words)
b        	jump backward by words (punctuation considered words)
0  		start of line
^        	first non-blank character of line
$        	end of line(include newline)
g_		Goto end of the line(no newline include better for copy)
G        	bottom of file
gg       	top of file
%		Moves cursor to the next bracket(or parenthesis)
(		Moves cursor to the previous sentence
)		Moves cursor to the next sentence
{		Moves cursor to the previous paragraph
}		Moves cursor to the next paragraph
#G       	goto line #

]'		Next mark line position
['		Previous mark line position
]`		Next mark line and column position
[`		Previous mark line and column position

'.       	jump back to last edited line
g;       	jump back to previous edited position
g,		jump back to next edited position
%		jump to the end of a block

ma       	set mark a at current cursor location
'a       	jump to line of mark a (first non-blank character in line)
`a		jump to line and column of mark a
g'a		jump to line of mark a without affect the jumps list
g`a		Jump to line and colum of mark a without affect the jump list
:marks   	list all the current marks
:delm!		Clear all marks[a-z]

H        	Jump to TOP of screen
M        	Jump to MIDDLE of screen
L        	Jump to BOTTOM of screen
C-f      	Move forward one full screen (page down)
C-b      	Move back one full screen (page up)
C-d      	Move forward 1/2 screen; half page down
C-u      	Move back (up) 1/2 screen; half page up
C-e		Show one more line at bottom
C-y		Show one more line at top of window

z<CR>		Reposition line with cursor: to top of screen
z.		Reposition line with cursor: to middle of screen
z-		Reposition line with cursor: to bottom of screen
zt 		Scroll the screen so the cursor is at the top
zb 		Scroll the screen so the cursor is at the bottom
zz		Shifts page content so current line sits at the middle of the viewport

zf		Create a fold
zc		Close the fold
zo		Open the fold
za		Alternate the fold

/<pattern>	Search forward for pattern
?<pattern>	Search backward for pattern
*		Searches forward for word under curso

C-a		Increment number under cursor
C-x		Decrement number under cursor

g-		Move backward through history, including previous branches
g+		Move forward through history, including previous branches

C-o		Move to previous jump position
C-i		Move to next jump position

gn		Search and edit next
gN		Search and edit previous

Q		Ex Mode

[Insert/Replace]

C-o		Go to normal mode and return to insert mode after the first command
C-r<REG>	Get the <REG> register content
C-r=		Enter an expression register


[Visual]
I		Insert
A		Append

o		Move the cursor to the opposite side
O		Move the cursor to the opposite side of the same line

"<REG>y		Copy selected region into register <REG> (Register [a-z])
"<REG>p		Paste selected region into register <REG>
c		Cut selection
gq		Reformat selection

i		Selected inside(use it with Text Object, ex: iw to select the word inside the cursor)
a		Selected around(use it with Text Object)
t		Selected until condition(ex: va[t) if you want to select block begin by '[' until ')' is found)

{Text Object} (using for selection)
- w[ord] 
- s[entences] 
- p[aragraphs] 
- t[ags] 
- '|"|`[quotes]
- {}|()|[]|<>[block]


[Windows]

c-w s		Split window horizontaly
c-w v		Split window verticaly
c-w [H|J|K|L]	Move windows to Left|Down|Up|Right

c-w +		Increase the window height by one row
c-w -		Reduces the window height by one row
c-w >		Increase the window width by one column
c-w < 		Reduces the window width by one column

c-w _		Enlarges current window height to full capacity
c-w |		Enlarges current window with to full capacity
c-w = 		Resize all windows to balanced dimension (equal space)

c-w T		Move window to a Tab

:sp {file}	Create horizontal window split
:vp {file}	Create vertical window split

[Tab]
:tabonly	Closing all tab
:tabmove 1	Move tab to position 1 [fist tab is 0]

[Command]

:wa		Saves all modified buffer
:x		Save and quit
:r[ead] [name] 	Insert the file [name] below the cursor.
:r[ead] !{cmd} 	Execute {cmd} and insert its standard output below the cursor.

:m[ove]{line}	Move content to {line}

:bufdo		Apply same command to all buffer
:windo		Apply same command to all windows(visible buffer)
:tabdo		Apply same command to all tab
:argdo		Apply same command to all args(list of args :args)	

:args		Display all arguments

:wundo {file}	Save change 
:rundo {file}	Load change

:changes	Show changes list
:changes {n}	Move cursor to the change number n

:jumps		Show jumps list
:keepjumps	Jump without recording jump in jump list (usefull for plugins)
		example: :keepjumps normal 5G
:clearjumps	Clear the jump list of the current window.

:g/{pattern}/{cmd}
		exemple :g/\v(a|g)/:d
		Erase all line begin by 'a' or 'g'
:%s/{pattern}/\={vimL}/
		example :%s/today/\=strftime("%c")/
		replace all 'today' with the actual date
:%s/{pattern}/\=@{register}/
		example :%s/\v(today)/\=@x/
		replace all 'today' with the content of register x

.		Current line
2,5		Range( line 2 to 5 )

:sba		Split all buffer in windows
:vert sba	Split verticaly all buffer in windows
:bd *.php<c-a>	Close all buffer with filename *.php
:bd 3 5		Close buffer 3 and 5
:4,7 bd		Close buffer 4 to 7(range)
:bufdo bd	Close all buffer

[Ex]

vim -E -s config.txt <<-EOF
	:%s/foo/bar
	:update
	:quit
EOF

:h holy-grail	See all vim commands



[Macro]

q{register}{commands}q
		Record macro{register}[0-9/a-z] with {commands}
		example: qa0f=wvg_xalog()<Esc>""Pjq

@{register}	Execute macro{register}
@@		Execute the last executed macro

5@:.		Execute the last command 5 times

:bufdo normal @a
		Execute macro 'a' on all buffers(Work only if set hidden)
:bufdo exe "normal @a" | write
		Execute macro 'a' on all buffers and write the changes

Redefine macro:
- add some action at the end 'qA'
- Change macro:
	:put a
	Change what you want
	0V
	"ay
[Marks]

:marks		List all the current marks.
:marks {arg}	List the marks that are mentioned in {arg} 
:delm {marks}	Delete the specified marks

{List of Marks Vim Automatically Generates}
'		Marks the line where the cursor jumped from (in current buffer)
`		Marks the position where the cursor jumped from (in current buffer)
.		Marks the position where the last change occured (in current buffer)
"		Marks the position where the user last exited the current buffer
[		Marks the beginning of the previously changed or yanked text
]		Marks the end of the previously changed or yanked text
<		Marks the beginning of the last visual selection
>		Marks the end of the last visual selection

[View]

:mkview [1-9|path]
		Create a view for the current file
:loadview [1-9]	Load a view
:source {path}	Load a view from file

[Session]

:mks[ession][!] [file]	Write a Vim script that restores the current editing session
			When [!] is included an existing file is overwritten.
			When [file] is omitted "Session.vim" is used.
:source {path}		Loading session from {path}

$> vim -S {path}	Loading sesssion, command line version
--------------------------------------------------------------------------------

Vim init:

autocmd BufNewFile *.html or ~/skeleton.html
	Insert a skeleton file if the file in the buffer don't exist

--------------------------------------------------------------------------------
Vim games:

- https://www.vimgolf.com
- https://vim-adventures.com

--------------------------------------------------------------------------------
