--------------------------------------------------------------------------------
				Vim command to learn
--------------------------------------------------------------------------------


[Normal]

ZZ 		Write current file, if modified, and exit.
gf 		Edit the file whose name is under or after the cursor. Mnemonic: "goto file".

gg=G		Indent all buffer ( gg -> beginning of the buffer / = -> indent until / G -> end of the buffer)
==		Indent the line under cursor
={txt_obj}	Indent text object(example: =i{ to indent inside a block)
={motion}	Indent motion(example: =% to indent under bracket)

V		Enter visual mode linewise
C-v		Enter visual mode for block selection
R		Replace mode
A		Place at the end of the line and enter Insert mode

f		Finds specified character to the right of the cursor position
F		Finds specified character to the left of the cursor position
;		Move to next occurrence of f/F
,		Move to previous occurrence of f/F
C-r		Redo
o		Begin a new line BELOW the cursor and insert text
s		Substitutes the character(or the selection of characters)
S		Substitutes the entire line
c		Change(not very well understand for the moment)
cc		Erase current line and set insert mode
cw		Erase word and set insert mode
D 		Delete the characters under the cursor until the end of the line
~ 		Switch case of the character under the cursor and move the cursor to the right. If a [count] is given, do that many characters.
.		Repeats the last INSERT edit
gx		Opens the URL under the cursor in a web browser

q[a-z]		Start recording, everything will be recorded including movement actions
@[a-z]		Execute the recorded actions

w        	jump by start of words (punctuation considered words)
e        	jump to end of words (punctuation considered words)
b        	jump backward by words (punctuation considered words)
0  		start of line
^        	first non-blank character of line
$        	end of line(include newline)
g_		Goto end of the line(no newline include better for copy)
G        	bottom of file
gg       	top of file
%		Moves cursor to the next bracket(or parenthesis)
(		Moves cursor to the previous sentence
)		Moves cursor to the next sentence
{		Moves cursor to the previous paragraph
}		Moves cursor to the next paragraph
#G       	goto line #

]'		Next mark line position
['		Previous mark line position
]`		Next mark line and column position
[`		Previous mark line and column position

]c		Move to next diff change
[c		Move to previous diff change

'.       	jump back to last edited line
g;       	jump back to previous edited position
g,		jump back to next edited position
%		jump to the end of a block
C-]		jump to definition (work only with ctags)

ma       	set mark a at current cursor location
'a       	jump to line of mark a (first non-blank character in line)
`a		jump to line and column of mark a
g'a		jump to line of mark a without affect the jumps list
g`a		Jump to line and column of mark a without affect the jump list
:marks   	list all the current marks
:delm!		Clear all marks[a-z]

H        	Jump to TOP of screen
M        	Jump to MIDDLE of screen
L        	Jump to BOTTOM of screen
C-f      	Move forward one full screen (page down)
C-b      	Move back one full screen (page up)
C-d      	Move forward 1/2 screen; half page down
C-u      	Move back (up) 1/2 screen; half page up
C-e		Show one more line at bottom
C-y		Show one more line at top of window

z<CR>		Reposition line with cursor: to top of screen
z.		Reposition line with cursor: to middle of screen
z-		Reposition line with cursor: to bottom of screen
zt 		Scroll the screen so the cursor is at the top
zb 		Scroll the screen so the cursor is at the bottom
zz		Shifts page content so current line sits at the middle of the viewport

zf		Create a fold
zc		Close the fold
zo		Open the fold
za		Alternate the fold

/<pattern>	Search forward for pattern
?<pattern>	Search backward for pattern
*		Searches forward for word under cursor

C-a		Increment number under cursor
C-x		Decrement number under cursor

g-		Move backward through history, including previous branches
g+		Move forward through history, including previous branches

C-o		Move to previous jump position
C-i		Move to next jump position

gn		Search and edit next
gN		Search and edit previous

Q		Ex Mode

J		Join lines, with a minimum of two lines(remove line break)
[Insert/Replace]

C-o		Go to normal mode and return to insert mode after the first command
C-r<REG>	Get the <REG> register content
C-r=		Enter an expression register


[Visual]
I		Insert
A		Append

o		Move the cursor to the opposite side
O		Move the cursor to the opposite side of the same line

"<REG>y		Copy selected region into register <REG> (Register [a-z])
"<REG>p		Paste selected region into register <REG>
c		Cut selection
gq		Reformat selection

i		Selected inside(use it with Text Object, ex: iw to select the word inside the cursor)
a		Selected around(use it with Text Object)
t		Selected until condition(ex: va[t) if you want to select block begin by '[' until ')' is found)

{Text Object} (using for selection)
- w[ord] 
- s[entences] 
- p[aragraphs] 
- t[ags] 
- '|"|`[quotes]
- {}|()|[]|<>[block]


[Windows]

c-w s		Split window horizontally
c-w v		Split window vertically
c-w [H|J|K|L]	Move windows to Left|Down|Up|Right

c-w +		Increase the window height by one row
c-w -		Reduces the window height by one row
c-w >		Increase the window width by one column
c-w < 		Reduces the window width by one column

c-w _		Enlarges current window height to full capacity
c-w |		Enlarges current window with to full capacity
c-w = 		Resize all windows to balanced dimension (equal space)

c-w T		Move window to a Tab

:sp {file}	Create horizontal window split
:vp {file}	Create vertical window split

[Tab]
:tabonly	Closing all tab
:tabmove 1	Move tab to position 1 [fist tab is 0]

[Command]

:wa		Saves all modified buffer
:x		Save and quit
:r[ead] [name] 	Insert the file [name] below the cursor.
:r[ead] !{cmd} 	Execute {cmd} and insert its standard output below the cursor.

:t		Copy

:! {cmd}	Execute {cmd} (Terminal command)
:'<,'>! {cmd}	Execute {cmd} on selected line
		example: :'<,'>! tr '[:lower:]' '[:upper:]'
			to transform selection to uppercase
:%! {cmd}	Execute {cmd} on the entire buffer
		example: :%! column -t
			to align all column

:m[ove]{line}	Move content to {line}

:bufdo		Apply same command to all buffer
:windo		Apply same command to all windows(visible buffer)
:tabdo		Apply same command to all tab
:argdo		Apply same command to all args(list of args :args)	

:args		Display all arguments

:wundo {file}	Save change 
:rundo {file}	Load change

:changes	Show changes list
:changes {n}	Move cursor to the change number n

:earlier {when}	Go to older buffer state. {when} can be COUNT, s, m, h, d, f
:later {when}	Go to newer buffer state

:jumps		Show jumps list
:keepjumps	Jump without recording jump in jump list (useful for plugins)
		example: :keepjumps normal 5G
:clearjumps	Clear the jump list of the current window.

:g/{pattern}/{cmd}
		example :g/\v(a|g)/:d
		Erase all line begin by 'a' or 'g'
:%s/{pattern}/\={vimL}/
		example :%s/today/\=strftime("%c")/
		replace all 'today' with the actual date
:%s/{pattern}/\=@{register}/
		example :%s/\v(today)/\=@x/
		replace all 'today' with the content of register x

.		Current line
2,5		Range( line 2 to 5 )

:sba		Split all buffer in windows
:vert sba	Split vertically all buffer in windows
:bd *.php<c-a>	Close all buffer with filename *.php
:bd 3 5		Close buffer 3 and 5
:4,7 bd		Close buffer 4 to 7(range)
:bufdo bd	Close all buffer

:difft[his]	Make the current window part of the diff windows
:windo difft	Diff all windows
:diffs[plit] {filename}
		Open a new window on the file {filename} to diff
:diffoff[!]	Turn off diff tools
:diffget	Gets change
:diffput	Puts change
do		Gets change
dp		Puts change
:diffupdate	Refresh all window viewports and update the diff highlighting
:TOhtml		Convert file to HTML, also convert diff

:map {key} {command}
		Map {key} to {command}
		example: 	:map j gg
				When you press j you go on top of the buffer
:noremap {key} {command}
		No recursive mapping {key} to {command}
		like map but without recurse
:nmap 		Normal mode mapping
:imap		Insert mode mapping
:xmap		Visual mode mapping
:smap		Select mode mapping
:vmap		Visual and Select mode mapping
:cmap		Command-line mode mapping
:omap		Operator pending mode
!! noremap version example vnoremap = Visual and Select no recurse mode mapping

:command [attributes] {name_of_command} {command}
		Create custom command
		example: :command ThisFile put %
		example with args: :command -nargs=+ Search execute 'vimgrep /' . [<f-args>][0] . '/ **/*.' . [<f-args>][1]

:Sexplore	Native vim file explorer with horizontal split window
:Explore	Native vim file explorer

:echo glob($VIMRUNTIME . '/syntax/*.vim)
		See all supported file type by vim
:set ft?	What filetype setting is used for this buffer
:setf {syntax}	Force {syntax} for this buffer

:sort		Sort all line in the buffer

[Ex]

vim -E -s config.txt <<-EOF
	:%s/foo/bar
	:update
	:quit
EOF


[Macro]

q{register}{commands}q
		Record macro{register}[0-9/a-z] with {commands}
		example: qa0f=wvg_xalog()<Esc>""Pjq

@{register}	Execute macro{register}
@@		Execute the last executed macro

5@:.		Execute the last command 5 times

:bufdo normal @a
		Execute macro 'a' on all buffers(Work only if set hidden)
:bufdo exe "normal @a" | write
		Execute macro 'a' on all buffers and write the changes

Redefine macro:
- add some action at the end 'qA'
- Change macro:
	:put a
	Change what you want
	0V
	"ay
[Marks]

:marks		List all the current marks.
:marks {arg}	List the marks that are mentioned in {arg} 
:delm {marks}	Delete the specified marks

{List of Marks Vim Automatically Generates}
'		Marks the line where the cursor jumped from (in current buffer)
`		Marks the position where the cursor jumped from (in current buffer)
.		Marks the position where the last change occurred (in current buffer)
"		Marks the position where the user last exited the current buffer
[		Marks the beginning of the previously changed or yanked text
]		Marks the end of the previously changed or yanked text
<		Marks the beginning of the last visual selection
>		Marks the end of the last visual selection

[View]

:mkview [1-9|path]
		Create a view for the current file
:loadview [1-9]	Load a view
:source {path}	Load a view from file

[Session]

:mks[ession][!] [file]	Write a Vim script that restores the current editing session
			When [!] is included an existing file is overwritten.
			When [file] is omitted "Session.vim" is used.
:source {path}		Loading session from {path}

$> vim -S {path}	Loading session, command line version

[Spell checking]

:setlocal spell spelllang=en_gb
			Set spellchecking for English(GB) !!On neowin not functionnal
:setlocal nospell	Disable spellchecking
z=			Suggest alternative word
<C-w>s			In insert mode auto-complete drop down list for word sugestion
]s			Move to the next misspelled word
[s			Move to the previous misspelled word
:spellr			Repeat last spelling correction

[Help]

:h holy-grail		See all vim commands
:h functions		See all vimL functions
:h tags			See tags help(command, usage, key bidding)
:h autocmd		See how to use autocmd
:h netrw		See help for native file explorer
:h spell		See help for spell checking
:h pattern-atoms	Sell list of all available atoms

--------------------------------------------------------------------------------
Vim init:

autocmd {event} {pattern} {cmd}
	Add {cmd} to the list of commands that Vim will execute automatically on {event} for a file matching {pattern}

autocmd BufNewFile *.html or ~/skeleton.html
	Insert a skeleton file if the file in the buffer don't exist

filetype indent on
	Active auto indentation

autocmd FileType sh,cucumber,ruby,yaml,zsh,vim setlocal shiftwidth=2 tabstop=2 expandtab

autocmd Bufread,BufNewFile *.md set filetype=markdown

--------------------------------------------------------------------------------
Vim command line:

nvim --headless -c "TOhtml|update|quit|quit" framedata.py
			To convert framedata.py to framedata.py.html
--------------------------------------------------------------------------------
Vim tricks:

:e **/*.py<TAB>		Cycle to all .py file of your project

d/{search}		Delete until found {search}

:t.			Duplicate line(like yyp)

:1,3t4			Duplicate line 1 to 3 and paste after line 4

4d 4			Start line 4 and delete 4 lines

c2l			Delete 2 character and place on Insert mode

:1,10 w {other_file}	Write line 1 to 10 to {other_file}

:1,10 w >> {other_file}	Append line 1 to 10 to the end of {other_file}

2f!			Move the cursor to the second '!' found of the current line

:%normal A!		Place '!' in the end of all line

:later 2f		File states, go back 2 buffer writes

:set scrollbind		Synchronize scroll with other windows
:set noscrollbind	Stop scroll synchronization

Files renaming example with an empty buffer:
:r! ls
ggdd
:%s/\v(\w)(\.txt)/mv & \L\1-\2/ | %s/\.txt$/\=strftime("%Y-%b-%d") . ".txt"/
:w !sh

--------------------------------------------------------------------------------
Vim games:

- https://www.vimgolf.com
- https://vim-adventures.com

--------------------------------------------------------------------------------
TMux:

<P>= TMux prefix key


<P>:list-keys		TMux key bidding information
<P>:list-commands	TMux commands list
<P>:info		TMux session information

<P>~			TMux messages
<P>:show-messages	TMux messages

<P>:choose-session	To change TMux session
<P>(			Move to next session
<P>)			Move to previous session
<P>$			Renaming session
<P>:rename-session -t {current_id} {new_id}
			Renaming session
$>tmux rename-session -t {current_id} {new_id}
			Renaming session

<P>:copy-mode
<P>[			Copy mode
<P>:paste-mode
<P>]			Paste last copy
<P>:list-buffers	
<P>#			List all copy buffer
<P>:show-buffer		Show last copy
<P>:capture-pane	Copy the entire pane
<P>:save-buffer {file}	Save the entire pane to {file}
<P>:choose-buffer
<P>=			Choose buffer to paste


{copy-mode}
:50			Goto line 50
/{pattern}		Search forward through the buffer
?{pattern}		Search backward through the buffer
<space>			Active selection
<CR> or q		Quit copy-mode

{Panes}
<P>:split-window -h
<P>%			Split pane horizontally
<P>:split-window -v
<P>"			Split pane vertically
<C-d>			Close a pane
<P>x			Force quit pane

<P>o			Cycle through pane
<P>:select-pane -L	
<P><left>		Move to pane Left
<P>:select-pane -R	
<P><right>		Move to pane Right
<P>:select-pane -U	
<P><up>			Move to pane Up
<P>:select-pane -D	
<P><down>		Move to pane Down
<P>q			Display numeric value on top of each pane
<P>q{pane_id}		Move to pane {pane_id}
<P>;			Goto last pane

<P><C-left>		Resize pane on left
<P><C-right>		Resize pane on right
<P><C-up>		Resize pane on up
<P><C-down>		Resize pane on down
<P><M-left>		Resize pane on left by 5
<P><M-right>		Resize pane on right by 5
<P><M-up>		Resize pane on up by 5
<P><M-down>		Resize pane on down by 5
<P>:resize-pane
<P>z			Resize pane to take all the place / return to normal size
<P>:break-pane
<P>!			Detach pane(transform pane to window)

<P>{			Rotate pane clockwise
<P>}			Rotate pane counterclockwise
<P><space>		Switch pane layout

<P>:select-layout even-horizontal
			Distribute same space horizontally on all pane
<P>:select-layout even-vertical
			Distribute same space vertically on all pane

{Windows}
<P>:new-window
<P>c			Create a new window
<P>:rename-window -t {window_id|window_name} {new_name}
			Rename windows({window_id} or {window_name}) with {new_name}

<P>:join-pane -s {source_window} -t {target_window}
			Join the source window into the target window
			Transform window to pane

<P>{window_id}		Goto {window_id} window
<P>n			Goto next window
<P>p			Goto previous window
<P>:choose-window
<P>w			Choose a window

{Synchronize pane}
<P>:setw synchronize-panes on
			Active pane synchronization
<P>:setw synchronize-panes off
			Disable pane synchronization

--------------------------------------------------------------------------------
